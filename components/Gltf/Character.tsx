/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/characterGiselleThreeJSWithAnimation-simp.glb -o components/Gltf/character.tsx -r public/models 
*/

import * as THREE from "three";
import React, {
    useEffect,
    useState,
    useCallback,
    useMemo,
    useLayoutEffect,
    useRef,
    MutableRefObject,
} from "react";
import { useGraph, useFrame } from "@react-three/fiber";
import { useGLTF, useAnimations, useScroll } from "@react-three/drei";
import { GLTF, SkeletonUtils } from "three-stdlib";
import gsap from "gsap";

export type BaseActionName =
    | "angry"
    | "breakdance"
    | "excited"
    | "fixGreeting"
    | "greeting"
    | "headMovments"
    | "idle"
    | "jogging"
    | "stopAndStartWalking"
    | "thankful"
    | "walking";

export type AdditiveActionName =
    | "angryFace"
    | "smile"
    | "happy"
    | "joggingFace"
    | "judgmental"
    | "prettyNice"
    | "sad"
    | "scared"
    | "smile"
    | "surprised"
    | "victory"
    | "blinkRight"
    | "blinkLeft"
    | "angryEyeLeft"
    | "angryEyeRight"
    | "wideOpenEyeRight"
    | "wideOpenEyeLeft";

interface GLTFAction extends THREE.AnimationClip {
    name: BaseActionName;
}

export type BaseActionsType = {
    [key in BaseActionName]: {
        weight: number;
        action?: THREE.AnimationAction;
    };
};

export type AdditiveActionsType = {
    [key in AdditiveActionName]: {
        weight: number;
        action?: THREE.AnimationAction;
    };
};

type GLTFResult = GLTF & {
    nodes: {
        earings: THREE.Mesh;
        ring: THREE.Mesh;
        ring001: THREE.Mesh;
        Cube066: THREE.Mesh;
        Cube066_1: THREE.Mesh;
        Cube058: THREE.Mesh;
        Cube058_1: THREE.Mesh;
        ears: THREE.SkinnedMesh;
        eyeballLeft: THREE.SkinnedMesh;
        eyeballRight: THREE.SkinnedMesh;
        eyebrows: THREE.SkinnedMesh;
        head001: THREE.SkinnedMesh;
        ["teeth-top"]: THREE.SkinnedMesh;
        ["theeth-bottom"]: THREE.SkinnedMesh;
        tongue_1: THREE.SkinnedMesh;
        ["arms-l"]: THREE.SkinnedMesh;
        ["arms-r"]: THREE.SkinnedMesh;
        boobs: THREE.SkinnedMesh;
        ["calfs-l"]: THREE.SkinnedMesh;
        ["calfs-r"]: THREE.SkinnedMesh;
        ["feets-l"]: THREE.SkinnedMesh;
        ["feets-r"]: THREE.SkinnedMesh;
        flipfingers: THREE.SkinnedMesh;
        ["forearms-l"]: THREE.SkinnedMesh;
        ["forearms-r"]: THREE.SkinnedMesh;
        hairsJoined: THREE.SkinnedMesh;
        hands: THREE.SkinnedMesh;
        neck: THREE.SkinnedMesh;
        nose: THREE.SkinnedMesh;
        pinkies: THREE.SkinnedMesh;
        pointers: THREE.SkinnedMesh;
        pullover: THREE.SkinnedMesh;
        ["pullover-sleevesl"]: THREE.SkinnedMesh;
        ["pullover-sleevesr"]: THREE.SkinnedMesh;
        skirt: THREE.SkinnedMesh;
        Plane003: THREE.SkinnedMesh;
        Plane003_1: THREE.SkinnedMesh;
        Plane003_2: THREE.SkinnedMesh;
        Plane003_3: THREE.SkinnedMesh;
        Plane003_4: THREE.SkinnedMesh;
        Plane040: THREE.SkinnedMesh;
        Plane040_1: THREE.SkinnedMesh;
        Plane040_2: THREE.SkinnedMesh;
        Plane040_3: THREE.SkinnedMesh;
        Plane040_4: THREE.SkinnedMesh;
        socks: THREE.SkinnedMesh;
        ["thighs-l"]: THREE.SkinnedMesh;
        ["thighs-r"]: THREE.SkinnedMesh;
        thumbs: THREE.SkinnedMesh;
        torso: THREE.SkinnedMesh;
        socks002: THREE.SkinnedMesh;
        mixamorigHips: THREE.Bone;
        Ctrl_Master: THREE.Bone;
        root: THREE.Bone;
        ["MCH-eyeparentL"]: THREE.Bone;
        ["MCH-eyeparentR"]: THREE.Bone;
        ["MCH-lip_armBL001"]: THREE.Bone;
        ["MCH-lip_armBR001"]: THREE.Bone;
        ["MCH-lip_armTL001"]: THREE.Bone;
        ["MCH-lip_armTR001"]: THREE.Bone;
        neutral_bone_1: THREE.Bone;
        Ctrl_ArmPole_IK_Left: THREE.Bone;
        Ctrl_Hand_IK_Left: THREE.Bone;
        Ctrl_ArmPole_IK_Right: THREE.Bone;
        Ctrl_Hand_IK_Right: THREE.Bone;
        Ctrl_Foot_IK_Left: THREE.Bone;
        Ctrl_LegPole_IK_Left: THREE.Bone;
        Ctrl_Foot_IK_Right: THREE.Bone;
        Ctrl_LegPole_IK_Right: THREE.Bone;
        neutral_bone: THREE.Bone;
    };
    materials: {
        ["Material.025"]: THREE.MeshStandardMaterial;
        ["Material.028"]: THREE.MeshStandardMaterial;
        ["Material.048"]: THREE.MeshPhysicalMaterial;
        ["Material.006"]: THREE.MeshStandardMaterial;
        ["Material.008"]: THREE.MeshStandardMaterial;
        ["Material.006"]: THREE.MeshStandardMaterial;
        ["Material.010"]: THREE.MeshStandardMaterial;
        ["Material.008"]: THREE.MeshStandardMaterial;
        ["Material.002"]: THREE.MeshStandardMaterial;
        ["Material.011"]: THREE.MeshStandardMaterial;
        ["Material.001"]: THREE.MeshStandardMaterial;
        ["Material.006"]: THREE.MeshStandardMaterial;
        ["Hair.003"]: THREE.MeshStandardMaterial;
        ["Material.024"]: THREE.MeshStandardMaterial;
        ["Material.024"]: THREE.MeshStandardMaterial;
        skirtMaterial: THREE.MeshStandardMaterial;
        ["Material.042"]: THREE.MeshStandardMaterial;
        ["Material.043"]: THREE.MeshPhysicalMaterial;
        ["Material.045"]: THREE.MeshStandardMaterial;
        ["Material.044"]: THREE.MeshStandardMaterial;
        ["Material.041"]: THREE.MeshStandardMaterial;
        ["Material.031"]: THREE.MeshStandardMaterial;
    };
    animations: GLTFAction[];
};

interface CharacterTyping extends React.ComponentProps<"group"> {
    isWireframe: boolean;
    animation: boolean;
    name: string;
    setAnimation: (prev: boolean) => void;
    section: number;
    theme: string | undefined;
    currentBaseAction: BaseActionName | "none";
    setCurrentBaseAction: React.Dispatch<
        React.SetStateAction<BaseActionName | "none">
    >;
    currentRefAction: MutableRefObject<string>;
    currentAdditiveAction: AdditiveActionName | "none";
    setCurrentAdditiveAction: React.Dispatch<
        React.SetStateAction<AdditiveActionName | "none">
    >;
    currentRefAdditiveAction: MutableRefObject<string>;
}

export function Character({
    isWireframe,
    animation,
    section,
    theme,
    currentBaseAction,
    setCurrentBaseAction,
    currentRefAction,
    currentAdditiveAction,
    setCurrentAdditiveAction,
    currentRefAdditiveAction,
    ...props
}: CharacterTyping) {
    const group = useRef<THREE.Group>(null);
    const { scene, animations } = useGLTF(
        "models/characterGiselleThreeJSWithAnimation.glb"
    );
    const clippingPlane = useMemo(() => {
        return new THREE.Plane(new THREE.Vector3(0, -3, 0), 1);
    }, []);
    const clippingPlaneIsWireframe = useMemo(() => {
        return new THREE.Plane(new THREE.Vector3(0, 3, 0), -1);
    }, []);

    const clone = React.useMemo(() => {
        const clonedScene = SkeletonUtils.clone(scene);
        clonedScene.traverse((child) => {
            if (child instanceof THREE.Mesh && child.material) {
                if (Array.isArray(child.material)) {
                    child.material = child.material.map((mat) => mat.clone());
                } else {
                    child.material = child.material.clone();
                    child.material.sheenRoughness = 0.15;
                    if (child.material.name === "Material.024") {
                        child.material.map.repeat = { x: 10, y: 10 };
                        child.material.normalMap.repeat = { x: 10, y: 10 };
                    }
                    if (isWireframe) {
                        child.material.map = null;
                        child.material.wireframe = true;
                        child.material.color = new THREE.Color(
                            theme === "dark" ? "#FFFADE" : "magenta"
                        );
                        child.material.emissive = new THREE.Color(
                            theme === "dark" ? "#FFFADE" : "magenta"
                        );
                        child.material.emissiveIntensity = 1;
                        child.material.sheen = 0;
                        child.material.metalness = 0;
                        child.material.roughness = 1;
                        child.material.clippingPlanes = [
                            clippingPlaneIsWireframe,
                        ];
                        child.material.needUpdate = true;
                        //child.material.side = THREE.DoubleSide;
                    } else {
                        child.material.clippingPlanes = [clippingPlane];
                    }

                    child.material.clipShadows = true;
                }
            }
        });
        return clonedScene;
    }, [isWireframe, scene, clippingPlane, clippingPlaneIsWireframe]);
    const { nodes, materials } = useGraph(clone) as GLTFResult;
    const { mixer } = useAnimations(animations, group);

    const [baseActions, setBaseActions] = useState<BaseActionsType>({
        idle: { weight: 1 },
        walking: { weight: 0 },
        stopAndStartWalking: { weight: 0 },
        greeting: { weight: 0 },
        breakdance: { weight: 0 },
        angry: { weight: 0 },
        excited: { weight: 0 },
        fixGreeting: { weight: 0 },
        headMovments: { weight: 0 },
        jogging: {
            weight: 0,
        },
        thankful: {
            weight: 0,
        },
    });
    const [additiveActions, setAdditiveActions] = useState<AdditiveActionsType>(
        () => ({
            blinkRight: { weight: 1 },
            blinkLeft: { weight: 1 },
            smile: { weight: 0 },
            angryFace: { weight: 0 },
            wideOpenEyeRight: { weight: 0 },
            wideOpenEyeLeft: { weight: 0 },
            angryEyeLeft: { weight: 0 },
            angryEyeRight: { weight: 0 },
            happy: { weight: 0 },
            joggingFace: { weight: 0 },
            judgmental: { weight: 0 },
            prettyNice: { weight: 0 },
            sad: { weight: 0 },
            scared: { weight: 0 },
            surprised: { weight: 0 },
            victory: { weight: 0 },
        })
    );

    const executeCrossFade = useCallback(
        (
            startAction: THREE.AnimationAction | null | undefined,
            endAction: THREE.AnimationAction | null | undefined,
            duration: number
        ) => {
            // Not only the start action, but also the end action must get a weight of 1 before fading
            // (concerning the start action this is already guaranteed in this place)

            if (endAction) {
                setWeight(endAction, 1);
                endAction.time = 0;

                if (startAction) {
                    // Crossfade with warping

                    startAction.crossFadeTo(endAction, duration, true);
                } else {
                    // Fade in

                    endAction.fadeIn(duration);
                }
            } else if (startAction) {
                // Fade out

                startAction.fadeOut(duration);
            }
        },
        []
    );

    const prepareCrossFade = useCallback(
        (
            startAction: THREE.AnimationAction | null | undefined,
            endAction: THREE.AnimationAction | null | undefined,
            duration: number,
            type: "face" | "animation"
        ) => {
            // if (currentBaseAction === "idle" || !startAction || !endAction) {
            executeCrossFade(startAction, endAction, duration);
            // } else {
            //     synchronizeCrossFade(startAction, endAction, duration);
            // }
            if (endAction) {
                const endClip = endAction.getClip();
                if (type == "animation") {
                    currentRefAction.current = endClip.name;
                    setCurrentBaseAction(endClip.name as BaseActionName);
                } else {
                    currentRefAdditiveAction.current = endClip.name;
                    setCurrentAdditiveAction(
                        endClip.name as AdditiveActionName
                    );
                }
            } else {
                if (type == "animation") {
                    currentRefAction.current = "none";
                    setCurrentBaseAction("none");
                } else {
                    currentRefAdditiveAction.current = "none";
                    setCurrentAdditiveAction("none");
                }
            }
        },
        [
            currentRefAction,
            currentRefAdditiveAction,
            executeCrossFade,
            setCurrentAdditiveAction,
            setCurrentBaseAction,
        ]
    );

    const playOnALoop = useCallback(
        (
            name: BaseActionName | AdditiveActionName | "none",
            type: "face" | "animation"
        ) => {
            let currentAction;
            let action;
            if (type === "face") {
                const currentSettings =
                    additiveActions[
                        currentRefAdditiveAction.current as AdditiveActionName
                    ];
                currentAction = currentSettings ? currentSettings.action : null;
                action = additiveActions[name as AdditiveActionName]
                    ? additiveActions[name as AdditiveActionName].action
                    : null;
            } else if (type === "animation") {
                const currentSettings =
                    baseActions[currentRefAction.current as BaseActionName];
                currentAction = currentSettings ? currentSettings.action : null;
                action = baseActions[name as BaseActionName]
                    ? baseActions[name as BaseActionName].action
                    : null;
            }

            if (currentAction !== action && action) {
                prepareCrossFade(currentAction, action, 0.35, type);
            }
        },
        [
            additiveActions,
            baseActions,
            currentRefAction,
            currentRefAdditiveAction,
            prepareCrossFade,
        ]
    );

    const scroll = useScroll();
    const tl = useRef(gsap.timeline());

    useEffect(() => {
        playOnALoop(currentBaseAction, "animation");
    }, [currentBaseAction, playOnALoop]);

    useEffect(() => {
        playOnALoop(currentAdditiveAction, "face");
    }, [currentAdditiveAction, playOnALoop]);

    useEffect(() => {
        clone.traverse((child) => {
            if (child instanceof THREE.Mesh && isWireframe) {
                child.material.color = new THREE.Color(
                    theme === "dark" ? "#FFFADE" : "magenta"
                );
                child.material.emissive = new THREE.Color(
                    theme === "dark" ? "#FFFADE" : "magenta"
                );
            }
        });
    }, [theme, clone, isWireframe]);

    useLayoutEffect(() => {
        tl.current = gsap.timeline();
        const mm = gsap.matchMedia();

        // ANIMATION DU PERSONNAGE SUR SCROLL

        mm.add("(min-width:769px)", () => {
            if (group.current) {
                tl.current.set(group.current.position, {
                    x: -4,
                    y: -4.5,
                    z: 0,
                });
                tl.current.set(group.current.rotation, {
                    x: 0,
                    y: 0.4,
                    z: 0,
                });
                tl.current.to(
                    group.current.position,
                    {
                        duration: 1,
                        x: 1.2,
                        y: -3.2,
                        z: 4.5,
                    },
                    0
                );
                tl.current.to(
                    group.current.rotation,
                    {
                        duration: 1,
                        y: -0.5,
                    },
                    0
                );
                tl.current.to(
                    group.current.position,
                    {
                        duration: 1,
                        x: -2,
                        y: -2.4,
                        z: 1,
                    },
                    1
                );
                tl.current.to(
                    group.current.rotation,
                    {
                        duration: 1,
                        y: 0.8,
                    },
                    1
                );
                tl.current.to(
                    group.current.position,
                    {
                        duration: 1,
                        x: 2,
                        y: -3,
                        z: 3,
                    },
                    2
                );
                tl.current.to(
                    group.current.rotation,
                    {
                        duration: 1,
                        y: -0.2,
                    },
                    2
                );
                tl.current.to(
                    group.current.position,
                    {
                        duration: 1,
                        x: 0,
                        y: -2.3,
                        z: 0.5,
                    },
                    3
                );
                tl.current.to(
                    group.current.rotation,
                    {
                        duration: 1,
                        y: 0,
                    },
                    3
                );
            }
            return () => {
                // cleanup function
                tl.current.kill();
            };
        });

        mm.add("(max-width:768px)", () => {
            if (group.current) {
                tl.current.set(group.current.position, {
                    x: 0,
                    y: 0.2,
                    z: -7.5,
                });
                tl.current.set(group.current.rotation, {
                    x: 0,
                    y: 0,
                    z: 0,
                });
                tl.current.to(
                    group.current.position,
                    {
                        x: 0,
                        y: -5.5,
                        z: 0,
                        duration: 1,
                    },
                    0
                );
                tl.current.to(
                    group.current.rotation,
                    {
                        y: -0.2,
                        duration: 1,
                    },
                    0
                );
                tl.current.to(
                    group.current.position,
                    {
                        duration: 1,
                        x: 0,
                        y: -1.5,
                        z: -3,
                    },
                    1
                );
                tl.current.to(
                    group.current.rotation,
                    {
                        duration: 1,
                        y: 0,
                    },
                    1
                );
                tl.current.to(
                    group.current.position,
                    {
                        duration: 1,
                        x: 0,
                        y: -4.2,
                        z: 3,
                    },
                    2
                );
                tl.current.to(
                    group.current.rotation,
                    {
                        duration: 1,
                        y: 0.5,
                    },
                    2
                );
                tl.current.to(
                    group.current.position,
                    {
                        duration: 1,
                        x: 0,
                        y: -3.5,
                        z: -3,
                    },
                    3
                );
                tl.current.to(
                    group.current.rotation,
                    {
                        duration: 1,
                        y: 0,
                    },
                    3
                );
            }
            return () => {
                tl.current.kill();
            };
        });

        //mm.kill();
    }, []);

    // const baseNames = ["None", ...Object.keys(baseActions)];
    // const baseNameButtons: {
    //     [name: string]: ButtonInput;
    // } = {};

    // baseNames.forEach((name) => {
    //     baseNameButtons[name] = button(() =>
    //         playOnALoop(name as BaseActionName)
    //     );
    // });

    // useControls({
    //     clippingPlane: {
    //         value: 1,
    //         min: -4.5,
    //         max: 1,
    //         onChange: (value) => {
    //             clippingPlane.constant = value;
    //         },
    //     },
    //     clippingPlaneIsWireframe: {
    //         value: -1,
    //         min: -1,
    //         max: 4.5,
    //         onChange: (value) => {
    //             clippingPlaneIsWireframe.constant = value;
    //         },
    //     },
    // idle: {
    //     value: 1,
    //     min: 0,
    //     max: 1,
    //     onChange: (value) => handleCurrentBaseAction("idle", value), // Callback appelé ici
    // },
    //     blinkLeft: {
    //         value: 1,
    //         min: 0,
    //         max: 1,
    //         onChange: (value) =>
    //             handleCurrentAdditiveAction("blinkLeft", value), // Callback appelé ici
    //     },
    //     blinkRight: {
    //         value: 1,
    //         min: 0,
    //         max: 1,
    //         onChange: (value) =>
    //             handleCurrentAdditiveAction("blinkRight", value), // Callback appelé ici
    //     },
    // ...baseNameButtons,
    // });

    // const playOnALoop = (action: BaseActionName) => {
    //  mixer.addEventListener("loop", onLoopFinished);
    //     const startAction = baseActions[currentBaseAction]
    //         .action as THREE.AnimationAction;
    //     const endAction = baseActions[action].action as THREE.AnimationAction;
    //     executeCrossFade(startAction, endAction, 0.35);
    // };

    // const synchronizeCrossFade = (
    //     startAction: THREE.AnimationAction,
    //     endAction: THREE.AnimationAction,
    //     duration: number
    // ) => {
    //     mixer.addEventListener("loop", onLoopFinished);

    //     function onLoopFinished(event: { action: THREE.AnimationAction }) {
    //         if (event.action === startAction) {
    //             mixer.removeEventListener("loop", onLoopFinished);
    //             executeCrossFade(startAction, endAction, duration);
    //         }
    //     }
    // };

    // const playOneLoop = (action: BaseActionName) => {
    //     //mixer.addEventListener("loop", onLoopFinished);
    //     const startAction = baseActions[currentBaseAction]
    //         .action as THREE.AnimationAction;
    //     const endAction = baseActions[action].action as THREE.AnimationAction;
    //     executeCrossFade(startAction, endAction, 0.35);

    //     mixer.addEventListener("loop", onOneLoopFinished);

    //     function onOneLoopFinished(event: { action: THREE.AnimationAction }) {
    //         //const clip = event.action.getClip();

    //         if (event.action === endAction) {
    //             mixer.removeEventListener("loop", onOneLoopFinished);

    //             executeCrossFade(endAction, startAction, 0.35);
    //         }
    //     }
    // };

    function setWeight(action: THREE.AnimationAction, weight: number) {
        action.enabled = true;
        action.setEffectiveTimeScale(1);
        action.setEffectiveWeight(weight);
    }

    const handleCurrentBaseAction = (
        action: BaseActionName,
        weight: number
    ) => {
        setBaseActions((prev) => ({
            ...prev,
            [action]: { ...prev[action], weight },
        }));
    };

    const handleCurrentAdditiveAction = (
        action: AdditiveActionName,
        weight: number
    ) => {
        setAdditiveActions((prev) => ({
            ...prev,
            [action]: { ...prev[action], weight },
        }));
    };

    const initAnimations = useCallback(() => {
        const allActions = [];

        function activateAction(action: THREE.AnimationAction) {
            const clip = action.getClip();
            const settings =
                baseActions[clip.name as BaseActionName] ||
                additiveActions[clip.name as AdditiveActionName];

            if (settings) {
                action.setEffectiveWeight(settings.weight);
            }
            action.play();
        }

        const numAnimations = animations.length;

        for (let i = 0; i !== numAnimations; i++) {
            const clip = animations[i];
            const name: BaseActionName & AdditiveActionName =
                clip.name as BaseActionName & AdditiveActionName;

            if (baseActions[name as BaseActionName]) {
                const action = mixer.clipAction(clip);
                activateAction(action);
                baseActions[name as BaseActionName].action = action;
                allActions.push(action);
            } else if (additiveActions[name]) {
                // if (name === "angryFace") {
                //     THREE.AnimationUtils.makeClipAdditive(clip);
                // }
                const action = mixer.clipAction(clip);
                activateAction(action);
                additiveActions[name as AdditiveActionName].action = action;
                allActions.push(action);
            }
        }
    }, [additiveActions, baseActions, mixer, animations]);

    useEffect(() => {
        const mm = gsap.matchMedia();
        if (animation) {
            if (isWireframe) {
                mm.add("(max-width:768px)", () =>
                    gsap.to(clippingPlaneIsWireframe, {
                        constant: 1.5,
                        duration: 2.5,
                        ease: "power3.inOut",
                    })
                );
                mm.add("(min-width:768px)", () =>
                    gsap.to(clippingPlaneIsWireframe, {
                        constant: 1,
                        duration: 2.5,
                        ease: "power3.inOut",
                    })
                );
            } else {
                mm.add("(max-width:768px)", () =>
                    gsap.to(clippingPlane, {
                        constant: -1.5,
                        duration: 2.5,
                        delay: 0.2,
                        ease: "power3.inOut",
                    })
                );
                mm.add("(min-width:768px)", () =>
                    gsap.to(clippingPlane, {
                        constant: -1,
                        duration: 2.5,
                        delay: 0.2,
                        ease: "power3.inOut",
                    })
                );
            }
        } else {
            if (isWireframe) {
                mm.add("(max-width:768px)", () =>
                    gsap.to(clippingPlaneIsWireframe, {
                        constant: -2,
                        duration: 2.5,
                        delay: 0.2,
                        ease: "power3.inOut",
                    })
                );
                mm.add("(min-width:768px)", () =>
                    gsap.to(clippingPlaneIsWireframe, {
                        constant: -1,
                        duration: 2.5,
                        delay: 0.2,
                        ease: "power3.inOut",
                    })
                );
            } else {
                mm.add("(max-width:768px)", () =>
                    gsap.to(clippingPlane, {
                        constant: 2,
                        duration: 2.5,
                        ease: "power3.inOut",
                    })
                );
                mm.add("(min-width:768px)", () =>
                    gsap.to(clippingPlane, {
                        constant: 1,
                        duration: 2.5,
                        ease: "power3.inOut",
                    })
                );
            }
        }
    }, [animation, isWireframe, clippingPlaneIsWireframe, clippingPlane]);

    useFrame(() => {
        //ANIMATION ON SCROLL
        tl.current.seek(scroll.offset * tl.current.duration());

        //ANIMATION ON CLICK
        if (animation) {
            const withWeightBase = Object.values(baseActions).filter(
                (el) => el.weight > 0
            );
            const withWeightAdditive = Object.values(additiveActions).filter(
                (el) => el.weight > 0
            );
            withWeightBase.forEach((el) => {
                const clip = el.action?.getClip();
                if (clip)
                    handleCurrentBaseAction(
                        clip.name as BaseActionName,
                        (el.weight -= 0.02)
                    );
            });
            withWeightAdditive.forEach((el) => {
                const clip = el.action?.getClip();
                if (clip)
                    handleCurrentAdditiveAction(
                        clip.name as AdditiveActionName,
                        (el.weight -= 0.02)
                    );
            });
            if (group.current) {
                group.current.rotation.y += 0.007; // Appliquer la rotation sur l'axe Y
            }
        } else {
            if (baseActions["idle"].weight < 1) {
                handleCurrentBaseAction(
                    "idle",
                    (baseActions["idle"].weight += 0.02)
                );
            }
            if (group.current && section === 4) {
                gsap.to(group.current.rotation, {
                    y: 0,
                    duration: 1,
                });
            }
        }
    });

    useEffect(() => {
        initAnimations();
    }, [initAnimations, additiveActions, baseActions]);

    useEffect(() => {
        Object.values(nodes).forEach((el) => {
            el.castShadow = true;
            el.receiveShadow = true;
        });
    }, [isWireframe, materials, clippingPlane, nodes]);

    return (
        <group ref={group} {...props} dispose={null}>
            <group name="Scene">
                <group name="Armature">
                    <primitive object={nodes.mixamorigHips} />
                    <primitive object={nodes.Ctrl_Master} />
                    <primitive object={nodes.Ctrl_ArmPole_IK_Left} />
                    <primitive object={nodes.Ctrl_Hand_IK_Left} />
                    <primitive object={nodes.Ctrl_ArmPole_IK_Right} />
                    <primitive object={nodes.Ctrl_Hand_IK_Right} />
                    <primitive object={nodes.Ctrl_Foot_IK_Left} />
                    <primitive object={nodes.Ctrl_LegPole_IK_Left} />
                    <primitive object={nodes.Ctrl_Foot_IK_Right} />
                    <primitive object={nodes.Ctrl_LegPole_IK_Right} />
                    <primitive object={nodes.neutral_bone} />
                    <skinnedMesh
                        name="arms-l"
                        geometry={nodes["arms-l"].geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes["arms-l"].skeleton}
                    />
                    <skinnedMesh
                        name="arms-r"
                        geometry={nodes["arms-r"].geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes["arms-r"].skeleton}
                    />
                    <skinnedMesh
                        name="boobs"
                        geometry={nodes.boobs.geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes.boobs.skeleton}
                    />
                    <skinnedMesh
                        name="calfs-l"
                        geometry={nodes["calfs-l"].geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes["calfs-l"].skeleton}
                    />
                    <skinnedMesh
                        name="calfs-r"
                        geometry={nodes["calfs-r"].geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes["calfs-r"].skeleton}
                    />
                    <skinnedMesh
                        name="feets-l"
                        geometry={nodes["feets-l"].geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes["feets-l"].skeleton}
                    />
                    <skinnedMesh
                        name="feets-r"
                        geometry={nodes["feets-r"].geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes["feets-r"].skeleton}
                    />
                    <skinnedMesh
                        name="flipfingers"
                        geometry={nodes.flipfingers.geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes.flipfingers.skeleton}
                    />
                    <skinnedMesh
                        name="forearms-l"
                        geometry={nodes["forearms-l"].geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes["forearms-l"].skeleton}
                    />
                    <skinnedMesh
                        name="forearms-r"
                        geometry={nodes["forearms-r"].geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes["forearms-r"].skeleton}
                    />
                    <skinnedMesh
                        name="hairsJoined"
                        geometry={nodes.hairsJoined.geometry}
                        material={materials["Hair.003"]}
                        skeleton={nodes.hairsJoined.skeleton}
                    />
                    <skinnedMesh
                        name="hands"
                        geometry={nodes.hands.geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes.hands.skeleton}
                    />
                    <skinnedMesh
                        name="neck"
                        geometry={nodes.neck.geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes.neck.skeleton}
                    />
                    <skinnedMesh
                        name="nose"
                        geometry={nodes.nose.geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes.nose.skeleton}
                    />
                    <skinnedMesh
                        name="pinkies"
                        geometry={nodes.pinkies.geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes.pinkies.skeleton}
                    />
                    <skinnedMesh
                        name="pointers"
                        geometry={nodes.pointers.geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes.pointers.skeleton}
                    />
                    <skinnedMesh
                        name="pullover"
                        geometry={nodes.pullover.geometry}
                        material={materials["Material.024"]}
                        skeleton={nodes.pullover.skeleton}
                    />
                    <skinnedMesh
                        name="pullover-sleevesl"
                        geometry={nodes["pullover-sleevesl"].geometry}
                        material={materials["Material.024"]}
                        skeleton={nodes["pullover-sleevesl"].skeleton}
                    />
                    <skinnedMesh
                        name="pullover-sleevesr"
                        geometry={nodes["pullover-sleevesr"].geometry}
                        material={materials["Material.024"]}
                        skeleton={nodes["pullover-sleevesr"].skeleton}
                    />
                    <skinnedMesh
                        name="skirt"
                        geometry={nodes.skirt.geometry}
                        material={materials.skirtMaterial}
                        skeleton={nodes.skirt.skeleton}
                    />
                    <group name="sneaker-joined001">
                        <skinnedMesh
                            name="Plane003"
                            geometry={nodes.Plane003.geometry}
                            material={materials["Material.042"]}
                            skeleton={nodes.Plane003.skeleton}
                        />
                        <skinnedMesh
                            name="Plane003_1"
                            geometry={nodes.Plane003_1.geometry}
                            material={materials["Material.043"]}
                            skeleton={nodes.Plane003_1.skeleton}
                        />
                        <skinnedMesh
                            name="Plane003_2"
                            geometry={nodes.Plane003_2.geometry}
                            material={materials["Material.045"]}
                            skeleton={nodes.Plane003_2.skeleton}
                        />
                        <skinnedMesh
                            name="Plane003_3"
                            geometry={nodes.Plane003_3.geometry}
                            material={materials["Material.044"]}
                            skeleton={nodes.Plane003_3.skeleton}
                        />
                        <skinnedMesh
                            name="Plane003_4"
                            geometry={nodes.Plane003_4.geometry}
                            material={materials["Material.041"]}
                            skeleton={nodes.Plane003_4.skeleton}
                        />
                    </group>
                    <group name="sneaker-joined034">
                        <skinnedMesh
                            name="Plane040"
                            geometry={nodes.Plane040.geometry}
                            material={materials["Material.042"]}
                            skeleton={nodes.Plane040.skeleton}
                        />
                        <skinnedMesh
                            name="Plane040_1"
                            geometry={nodes.Plane040_1.geometry}
                            material={materials["Material.043"]}
                            skeleton={nodes.Plane040_1.skeleton}
                        />
                        <skinnedMesh
                            name="Plane040_2"
                            geometry={nodes.Plane040_2.geometry}
                            material={materials["Material.045"]}
                            skeleton={nodes.Plane040_2.skeleton}
                        />
                        <skinnedMesh
                            name="Plane040_3"
                            geometry={nodes.Plane040_3.geometry}
                            material={materials["Material.044"]}
                            skeleton={nodes.Plane040_3.skeleton}
                        />
                        <skinnedMesh
                            name="Plane040_4"
                            geometry={nodes.Plane040_4.geometry}
                            material={materials["Material.041"]}
                            skeleton={nodes.Plane040_4.skeleton}
                        />
                    </group>
                    <skinnedMesh
                        name="socks"
                        geometry={nodes.socks.geometry}
                        material={materials["Material.031"]}
                        skeleton={nodes.socks.skeleton}
                    />
                    <skinnedMesh
                        name="thighs-l"
                        geometry={nodes["thighs-l"].geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes["thighs-l"].skeleton}
                    />
                    <skinnedMesh
                        name="thighs-r"
                        geometry={nodes["thighs-r"].geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes["thighs-r"].skeleton}
                    />
                    <skinnedMesh
                        name="thumbs"
                        geometry={nodes.thumbs.geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes.thumbs.skeleton}
                    />
                    <skinnedMesh
                        name="torso"
                        geometry={nodes.torso.geometry}
                        material={materials["Material.006"]}
                        skeleton={nodes.torso.skeleton}
                    />
                </group>
                <skinnedMesh
                    name="socks002"
                    geometry={nodes.socks002.geometry}
                    material={materials["Material.031"]}
                    skeleton={nodes.socks002.skeleton}
                />
            </group>
        </group>
    );
}

useGLTF.preload("models/characterGiselleThreeJSWithAnimation.glb");
